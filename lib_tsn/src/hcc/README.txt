There's no changes to AVB API other than the new #define AVB_CHANNEL_COALESCENCE_FACTOR to enable HCC (in the "avb_defaults.h" file).  Generally this #define should be set to the channels per stream for maximum optimization.  It can be set to less than 'channels per stream' but only values of 2^n are valid.

Essentially the coalescence factor sets the number of audio channels per channel FIFO.  Original TSN code is implemented such that there's one channel per FIFO.  Samples are moved through FIFO's one at time.  And the clock management observes each and every FIFO.  Both of these result in a lot of FIFO related activity (push one channel sample, update FIFO data pointers, check for zeroing or other flags, update timestamps, etc).

By setting the COALESCENCE value equal to the channels per stream you then end up with just one FIFO per stream.  Each FIFO now stores all samples for each stream's channels in an a sample array.  The FIFO still stores N number of audio cycles as before.  Before it stored N cycles of 1 channel.  After coalescence it stores N cycles of M channels where M = the coalescence factor.

For example; 4 streams of 8 channels each originally results in 32 FIFO's with each FIFO storing N cycles of one channel's worth of data in an array of length 1.  Each FIFO's timing information, FIFO management variables, FIFO sample buffer, etc. are all managed and updated - very often!  Lots of overhead but it provides maximum flexibility in that channel mapping between input and output streams can by just about anything.

The channel mapping can be moved out of lib_tsn and into the application space.  This makes more sense anyway since the application may also want to apply mixing or muxing/switching of other audio data (from I2S, USB, etc) based on a complex channel mapping table.  Moving the channel mapping out of lib_tsn allows for coalescing channels since the mapping is constant and the mapping from in to out is sequenced as 0-->0, 1-->1, 2-->2, etc.

Setting COALESCENCE to 8, for the example of 4 streams of 8 channels each, results in two FIFO's where each FIFO buffer stores N cycles of arrays - each array storing a sample for each channel.  The FIFO's timing info and push/pop pointers still function the same way as before therefore this optimization should not effect clock recovery functionality and behavior.  As a matter of fact the original approach of managing timing of multiple FIFO's for channels for the same stream seem completely redundant anyway.

Future optimizations are still possible.  FIFO buffers should be declared at static/global scope to enforce 64-bit alignment.  This would allow sample copying between FIFO's and audio buffers to use double-word loads/stores in the xCORE-200.  Also, the 1722 packets should be encapsulated and padded such that the area of the sample data within the packet is 64-bit aligned to support LDD/SDD moves between listener/talker payloads and FIFO's.
